## Java继承

* 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

* **类的继承格式**

  ```
  class 父类 {
  }
   
  class 子类 extends 父类 {
  }
  ```

  

* **继承类型**

  * 单继承

    ```
    public class A{......}
    public class B extends A{......}
    ```

    

  * 多重继承

    ```
    public class A{......}
    public class B extends A{......}
    public class C extends B{......}
    ```

    

  * 不同类继承同一个类

    ```
    public class A{......}
    public class B extends A{......}
    public class C extends A{......}
    ```

    

  * 多继承（不支持）；Java不支持多继承，但支持多重继承

    ```
    public class A{......}
    public class B{......}
    public class C extends A,B{......}//Java不支持多继承
    ```

    

* 继承的**特性**

  * 子类拥有父类非 private 的属性、方法。
  * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
  * 子类可以用自己的方式实现父类的方法。
  * Java 的继承是单继承，也可以多重继承。
  * 类之间的耦合性高，代码独立性差。

* 继承**关键字**

  继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。

  * **extends关键字**

    在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。

    ```
    public class Animal { 
    	......
    }
    public class Penguin extends Animal{ 
    	......
    }
    ```

    

  * **implements关键字**

    使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。

    ```
    public interface A {
    	......
    }
    public interface A {
    	......
    }
    public class C implements A,B {
    }
    ```

    

  * **super与this关键字**

    ```
    class Animal {
      void eat() {
        System.out.println("animal : eat");
      }
    }
     
    class Dog extends Animal {
      void eat() {
        System.out.println("dog : eat");
      }
      void eatTest() {
        this.eat();   // this 调用自己的方法
        super.eat();  // super 调用父类方法
      }
    }
    ```

    

  * **final关键字**

    final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：

    * 声明类

      ```
      final class 类名 {//类体}
      ```

      

    * 声明方法

      ```
      修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体}
      ```

      

* **构造器**

  子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。

  如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。

## Java重写(Override)与重载(Overload)

* **重写（Override）**

  * 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

  * 当需要在子类中调用父类的被重写方法时，要使用**super**关键字。

* **重载（Overload）**

  * 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
  * 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
  * 最常用的地方就是构造器的重载。

* 重写与重载之间的**区别**

  | 区别点   | 重载方法 | 重写方法                                       |
  | -------- | -------- | ---------------------------------------------- |
  | 参数列表 | 必须修改 | 一定不能修改                                   |
  | 返回类型 | 可以修改 | 一定不能修改                                   |
  | 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |
  | 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |

  

* **总结**

  方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

  * 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
  * 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
  * 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。



## Java多态

* 多态是同一个行为具有多个不同表现形式或形态的能力。

* **多态存在的三个必要条件**

  * 继承
  * 重写
  * 父类引用指向子类对象

  ```
  Parent p = new Child();
  ```

  当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

* **虚函数**

  虚函数的存在是为了多态。

  Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。

* **多态的实现方式**

  * **重写**
  * **接口**
  * **抽象类和抽象方法**



## Java封装

* 封装的**优点**

  * 良好的封装能够减少耦合。
  *  类内部的结构可以自由修改。
  * 可以对成员变量进行更精确的控制。
  * 隐藏信息，实现细节。

* 实现Java封装的步骤

  * 修改属性的可见性来限制对属性的访问（一般限制为private，只能本类才能访问，其他类都访问不了）

    ```
    public class Person {
        private int age;
    }
    ```

    

  * 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问

    ```
    public class Person{
        private int age;
    
        public int getAge(){
          return age;
        }
    
        public void setAge(int age){
          this.age = age;
        }
        
    }
    ```

    采用 **this** 关键字是为了解决实例变量（private int age）和局部变量（setAge(int age)中的age变量）之间发生的同名的冲突。

  * 任何要访问类中私有成员变量的类都要通过这些getter和setter方法。



## Java接口

* Java接口

  * 类描述对象的属性和方法。接口则包含类要实现的方法。

  * 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

  * 接口无法被实例化，但是可以被实现。

* 接口与类的**相似点**

  * 一个接口可以有多个方法。
  * 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
  * 接口的字节码文件保存在 .class 结尾的文件中。
  * 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

* 接口与类的**区别**

  * 接口不能用于实例化对象。
  * 接口没有构造方法。
  * 接口中所有的方法必须是抽象方法。
  * 接口不能包含成员变量，除了 static 和 final 变量。
  * 接口不是被类继承了，而是要被类实现。
  * 接口支持多继承。

* 接口特性

  * 接口中的方法会被隐式的指定为 **public abstract**
  * 接口中的变量会被隐式的指定为 **public static final** 变量
  * 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

* 抽象类和接口的**区别**

  * 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
  * 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
  * 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
  * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

* 接口的**声明interface**

  ```
  [可见度] interface 接口名称 [extends 其他的接口名] {
          // 声明变量
          // 抽象方法
  }
  ```

  ```
  interface Animal {
     public void eat();
  }
  ```

  

* 接口的**实现implements**

  ```
  ...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...
  ```

  ```
  public class MammalInt implements Animal{
   
     public void eat(){
        System.out.println("Mammal eats");
     }
  }
  ```

  

* 接口的**继承**

  接口的继承使用extends关键字，子接口继承父接口的方法

* 接口的**多继承**

  在Java中，类的多继承是不合法，但接口允许多继承。

  在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 

  ```
  public interface Hockey extends Sports, Event
  ```

  

* **标记接口**

  * 标记接口是没有任何方法和属性的接口。
  * 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。
  * 标记接口目的：
    * 建立一个公共的父接口
    * 向一个类添加数据类型



## 观察者模式

* 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

* 观察者模式使用三个类 Subject、Observer 和 Client。
* **意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
* **主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
* **何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
* **如何解决：**使用面向对象技术，可以将这种依赖关系弱化。
* **关键代码：**在抽象类里有一个 ArrayList 存放观察者们。

